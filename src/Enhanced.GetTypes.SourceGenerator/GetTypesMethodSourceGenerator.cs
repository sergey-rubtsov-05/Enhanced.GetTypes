using System.Collections.Immutable;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Enhanced.GetTypes.SourceGenerator;

[Generator]
internal class GetTypesMethodSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
                              .CreateSyntaxProvider(
                                  (node, _) => node is MethodDeclarationSyntax
                                  {
                                      AttributeLists.Count: > 0, Modifiers: { Count: > 0 }
                                  },
                                  (ctx, _) => GetMethodDeclarationForSourceGen(ctx))
                              .Where(t => t.matches)
                              .Select((t, _) => t.method);

        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
    }

    private static (MethodDeclarationSyntax method, bool matches) GetMethodDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var methodDeclarationSyntax = (MethodDeclarationSyntax)context.Node;

        foreach (var attributeListSyntax in methodDeclarationSyntax.AttributeLists)
        foreach (var attributeSyntax in attributeListSyntax.Attributes)
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
            {
                continue;
            }

            var attributeType = attributeSymbol.ContainingType.ToDisplayString();

            if (attributeType != DerivedTypesAttributeMetadata.FullName)
            {
                continue;
            }

            return (methodDeclarationSyntax, true);
        }

        return (methodDeclarationSyntax, false);
    }

    private static void GenerateCode(SourceProductionContext ctx, Compilation compilation,
        ImmutableArray<MethodDeclarationSyntax> methodDeclarations)
    {
        foreach (var methodDeclaration in methodDeclarations)
        {
            var semanticModel = compilation.GetSemanticModel(methodDeclaration.SyntaxTree);
            var methodSymbol = (IMethodSymbol?)semanticModel.GetDeclaredSymbol(methodDeclaration);

            if (methodSymbol is null)
            {
                ctx.ReportDiagnostic(
                    Diagnostics.UnexpectedError.ToDiagnostic(
                        methodDeclaration.GetLocation(),
                        "Method symbol is null"));
                continue;
            }

            if (!methodSymbol.IsPartialDefinition)
            {
                ctx.ReportDiagnostic(Diagnostics.MethodNotPartial.ToDiagnostic(methodDeclaration.GetLocation()));
                continue;
            }

            if (methodSymbol.Parameters.Length > 0)
            {
                ctx.ReportDiagnostic(Diagnostics.MethodHasParameters.ToDiagnostic(methodDeclaration.GetLocation()));
                continue;
            }

            var returnType = methodSymbol.ReturnType.ToDisplayString();
            if (returnType != "System.Collections.Generic.IEnumerable<System.Type>")
            {
                ctx.ReportDiagnostic(Diagnostics.MethodReturnTypeInvalid.ToDiagnostic(methodDeclaration.GetLocation()));
                continue;
            }

            var attribute = methodSymbol.GetAttribute(DerivedTypesAttributeMetadata.FullName);
            var derivedTypesAttribute = DerivedTypesAttributeData.FromAttribute(attribute);

            if (derivedTypesAttribute is null)
            {
                ctx.ReportDiagnostic(
                    Diagnostics.UnexpectedError.ToDiagnostic(
                        methodDeclaration.GetLocation(),
                        "Model symbol is null"));
                continue;
            }

            var sourceFileName = $"{methodSymbol.ContainingType.Name}.{methodSymbol.Name}.g.cs";
            var sourceText = GenerateCore(compilation, methodSymbol, derivedTypesAttribute);

            ctx.AddSource(sourceFileName, sourceText);
        }
    }

    private static string GenerateCore(
        Compilation compilation, IMethodSymbol methodSymbol, DerivedTypesAttributeData attribute)
    {
        var derivedTypesVisitor = new DerivedTypesLookupVisitor(attribute);
        compilation.Assembly.Accept(derivedTypesVisitor);

        var writer = new PartialClassWriter();

        writer.WriteAutoGeneratedHeader();

        using (writer.BeginNamespace(methodSymbol.ContainingNamespace))
        using (writer.BeginClass(methodSymbol.ContainingType))
        using (writer.BeginMethod(methodSymbol))
        {
            foreach (var derivedType in derivedTypesVisitor.DerivedTypes)
            {
                writer.WriteLine($"yield return typeof({derivedType.ToDisplayString().Replace("<T>", "<>")});");
            }

            writer.WriteLine("yield break;");
        }

        return writer.ToString();
    }
}
